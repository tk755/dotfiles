#!/usr/bin/env bash
# Defines bash prompt

# returns system date in nanoseconds
function timestamp {
    date +%s%N
}

# sets $cmd_timer if not set
function timer_start {
    cmd_timer=${cmd_timer:-$(timestamp)}
}

# DEBUG trap is executed just before a command
# i.e. start the timer before executing a command
trap timer_start DEBUG

# returns formatted timer prompt segment
function timer_segment {
    # delta microseconds
    local delta_us=$(( ($(timestamp) - $cmd_timer) / (1000) ))

    # extract time for each unit
    local h=$(( (delta_us / (1000 * 1000 * 60 * 60))        ))
    local m=$(( (delta_us / (1000 * 1000 * 60)     ) % 60   ))
    local s=$(( (delta_us / (1000 * 1000)          ) % 60   ))
    local ms=$(( delta_us /  1000                    % 1000 ))
    local us=$(( delta_us                            % 1000 ))

    # create formatted timer segment
    local ts # timer string

    if (( h > 0 )); then
        ts="${h}h $(printf '%02d' ${m})m"
    elif (( m > 0 )); then
        ts="${m}m $(printf '%02d' ${s})s"
    elif (( s > 0 )); then
        ts="${s}.$(printf '%01d' $(( ${ms} / 100 )))s"
    elif (( ms >= 100 )); then
        ts="${ms}ms"
    elif (( ms > 0 )); then
        ts="${ms}.$(printf '%01d' $(( ${us} / 100 )))ms"
    else
        ts="${us}Âµs"
    fi

    echo "${C_DARK_GRAY}${ts}${C_DEFAULT}"
}

# returns formatted exit code prompt segment
function exit_segment {
    local exit_code="$?"

    # create formatted exit code segment
    local ec # exit code color
    local es # exit code string

    if [[ $exit_code == 0 ]]; then
        ec=${C_GREEN}
        es='\342\234\224' # check mark
    else
        ec=${C_RED}
        es='\342\234\230' # x cross
    fi

    echo ${ec}${es}${C_DEFAULT}
}

# sets $PS1 and resets the timer
function set_prompt {
    # build header segments
    local exit=$(exit_segment) # this must be first
    local timer=$(timer_segment)
    local prompt="${C_LIGHT_MAGENTA}$ ${C_DEFAULT}"

    local top_connector="${C_DARK_GRAY} \342\224\216 ${C_DEFAULT}"
    local bottom_connector="${C_DARK_GRAY} \342\224\226 ${C_DEFAULT}"

    # assemble left and right parts of the header
    local left="${top_connector}${C_DARK_GRAY}\!${C_LIGHT_GREEN} \u@\h ${C_DEFAULT}:${C_LIGHT_BLUE} \w ${C_DEFAULT}"
    local right="${timer} ${exit} "

    # assemble header with filler space between left and right parts
    # https://superuser.com/a/517110
    local right_offset=51 # this is to compensate for escape sequences
    PS1=$(printf "%*s\r%s\n${bottom_connector}${prompt}" "$(( $(tput cols) + right_offset ))" "${right}" "${left}")

    # reset the timer
    unset cmd_timer # this must be last
}

# PROMPT_COMMAND is executed just before Bash prints the primary prompt
PROMPT_COMMAND=set_prompt

# ansi color definitions
C_DEFAULT="\[\e[39m\]"

C_BLACK="\[\e[30m\]"
C_WHITE="\[\e[97m\]"

C_LIGHT_GRAY="\[\e[37m\]"
C_DARK_GRAY="\[\e[90m\]"

C_RED="\[\e[31m\]"
C_LIGHT_RED="\[\e[91m\]"

C_YELLOW="\[\e[33m\]"
C_LIGHT_YELLOW="\[\e[93m\]"

C_GREEN="\[\e[32m\]"
C_LIGHT_GREEN="\[\e[92m\]"

C_CYAN="\[\e[36m\]"
C_LIGHT_CYAN="\[\e[96m\]"

C_BLUE="\[\e[34m\]"
C_LIGHT_BLUE="\[\e[94m\]"

C_MAGENTA="\[\e[35m\]"
C_LIGHT_MAGENTA="\[\e[95m\]"