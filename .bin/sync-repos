#!/usr/bin/env bash
# sync-repos - script to sync all public and private GitHub repositories
# For usage instructions, run `sync-repos --help`

set -euo pipefail

# config
GITHUB_USER="tk755"
REPO_DIR="$HOME/repos"

# repo patterns to exclude (via substring matches)
REPO_EXCLUDE=(
    "dotfiles"
    "CS-3110"
)

# default flags
INCLUDE_SKIPPED=false
SHOW_SKIPPED=false

print_help() {
    cat <<EOF
Usage: sync-repos [OPTIONS]

Options:
    --include-skipped   Include archived and excluded repositories
    --show-skipped      Show status messages for skipped repositories
    --help              Show this help message
EOF
}

is_excluded() {
    local repo="$1"
    for pattern in "${REPO_EXCLUDE[@]}"; do
        case "$repo" in
            *"$pattern"*) return 0 ;;
        esac
    done
    return 1
}

print_status() {
    # usage: print_status "repo" "message" "emoji"
    local repo="$1"
    local message="$2"
    local emoji="$3"

    # color emoji based on type
    local color
    case "$emoji" in
        "+" )  color="\e[35m" ;;  # purple
        "↓" )  color="\e[36m" ;;  # cyan
        "✓" )  color="\e[32m" ;;  # green
        "×" )  color="\e[31m" ;;  # red
        "–" )  color="\e[33m" ;;  # yellow
        * )    color="\e[0m"  ;;  # default
    esac

    printf "%-${REPO_COL_WIDTH}s %b%s%b %s\n" "$repo" "$color" "$emoji" "\e[0m" "$message"
}

pull_repo() {
    local repo="$1"
    cd "$repo"

    # ensure we are on a branch with an upstream
    local branch
    if ! branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null); then
        print_status "$repo" "No branch" "×"
        cd "$REPO_DIR"
        return
    fi

    if ! git rev-parse --abbrev-ref "@{u}" > /dev/null 2>&1; then
        print_status "$repo" "No upstream" "×"
        cd "$REPO_DIR"
        return
    fi

    local LOCAL REMOTE BASE
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse "@{u}")
    BASE=$(git merge-base @ "@{u}" 2>/dev/null || true)

    if [ -z "$BASE" ]; then
        print_status "$repo" "Unrelated history" "×"
    elif [ "$LOCAL" = "$REMOTE" ]; then
        print_status "$repo" "Up-to-date" "✓"
    elif [ "$LOCAL" = "$BASE" ]; then
        if git pull --ff-only --quiet; then
            print_status "$repo" "Pulled" "↓"
        else
            print_status "$repo" "Local changes" "×"
        fi
    else
        print_status "$repo" "Diverged" "×"
    fi

    cd "$REPO_DIR"
}

clone_repo() {
    local repo="$1"
    if true || gh repo clone "$GITHUB_USER/$repo" "$repo" > /dev/null 2>&1; then
        print_status "$repo" "Cloned" "+"
    else
        print_status "$repo" "Clone failed" "×"
        return
    fi
}

skip_message() {
    local reason="$1"
    local repo="$2"
    if [ "$SHOW_SKIPPED" = true ]; then
        print_status "$repo" "Skipped ($reason)" "–"
    fi
}

# parse args
for arg in "$@"; do
    case "$arg" in
        --show-skipped)    SHOW_SKIPPED=true ;;
        --include-skipped) INCLUDE_SKIPPED=true ;;
        --help)            print_help ; exit 0 ;;
        *) echo "Unknown argument: $arg" && exit 1 ;;
    esac
done

# check auth
if ! gh auth status > /dev/null 2>&1; then
    echo "You must run 'gh auth login' first."
    exit 1
fi

mkdir -p "$REPO_DIR"
cd "$REPO_DIR"

echo -e "\e[1mSyncing all public and private repositories for $GITHUB_USER to $REPO_DIR\e[0m"

# fetch repo names and archive status as tsv
repo_data=$(gh repo list "$GITHUB_USER" --limit 1000 --json name,isArchived \
  --jq '.[] | [.name, (.isArchived | tostring | ascii_downcase)] | @tsv')

# calculate column width for repo names
REPO_COL_WIDTH=$(( $(echo "$repo_data" | awk '{print length($1)}' | sort -nr | head -n1) + 2 ))

# loop through repo names and archive status
echo "$repo_data" | while IFS=$'\t' read -r repo is_archived; do
    if [ -d "$repo/.git" ]; then
        pull_repo "$repo"
    elif [ "$INCLUDE_SKIPPED" = false ] && [ "$is_archived" = "true" ]; then
        skip_message "archived" "$repo"
    elif [ "$INCLUDE_SKIPPED" = false ] && is_excluded "$repo"; then
        skip_message "excluded" "$repo"
    else
        clone_repo "$repo"
    fi
done

echo -e "\e[1m\e[32mRepository sync complete\e[0m"
