#!/usr/bin/env bash

set -euo pipefail

REPO_URL_HTTPS="https://github.com/tk755/dotfiles.git"
DOTFILES_DIR="$HOME/.dotfiles"

# paths to exclude in headless install
HEADLESS_EXCLUDES=(
    ".config/i3"
    ".fonts"
    ".icons"
    ".themes"
    ".Xresources"
)

# default flags
HEADLESS=false
ALL=false
FORCE=false

print_help() {
    cat <<EOF
Usage: bootstrap [OPTIONS]

Options:
    --headless      Exclude GUI-related dotfiles (for servers or WSL)
    --force         Force overwrite local files (destructive)
    --help          Show this help message

Exclude patterns (--headless):
    ${HEADLESS_EXCLUDES[*]}

Description:
    Installs dotfiles from https://github.com/tk755/dotfiles.git
    using a bare git clone with sparse checkout.

    On each run, the latest version of the repository is cloned.
    By default, any conflicting non-image local files are preserved:
      - They are backed up before checkout and restored afterward.
      - Use --force to skip backup and overwrite all conflicts.
    
    All files in the repository are included by default.
      - Use --headless to exclude GUI-related files via sparse checkout.
EOF
}

parse_args() {
    for arg in "$@"; do
        case "$arg" in
            --all)      ALL=true                    ;;
            --headless) HEADLESS=true               ;;
            --force)    FORCE=true                  ;;
            --help)     print_help && exit 0        ;;
            *) echo "Invalid arg: $arg" && exit 1   ;;
        esac
    done

    if [ $ALL = true ] && [ $HEADLESS = true ]; then
        echo "Error: --headless and --all are mutually exclusive." >&2
        exit 1
    fi
}

print_bold() {
    printf "\e[1m%s\e[0m\n" "$1"
}

print_dim() {
    printf "\e[2m%s\e[0m\n" "$1"
}

# dotfiles git wrapper function
dotfiles() {
    git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

clone_repo() {
    # clone via HTTPS to avoid SSH setup issues
    echo " ⮞ Cloning repo from $REPO_URL_HTTPS"
    git clone --bare "$REPO_URL_HTTPS" "$DOTFILES_DIR" &> /dev/null

    # change url to SSH for future pushes
    REPO_URL_SSH="git@github.com:${REPO_URL_HTTPS#https://github.com/}"
    git --git-dir="$DOTFILES_DIR" remote set-url origin "$REPO_URL_SSH"

    # manually configure tracking
    dotfiles config branch.main.remote origin
    dotfiles config branch.main.merge refs/heads/main

    # disable untracked files in status
    dotfiles config --local status.showUntrackedFiles no

    # enable
    dotfiles config core.sparseCheckout true
}

setup_sparse_checkout() {
    # create sparse checkout file if it doesn't exist
    local sparse_file="$DOTFILES_DIR/info/sparse-checkout"
    mkdir -p "$(dirname "$sparse_file")"

    # update sparse checkout file
    if [ "$HEADLESS" = true ]; then
        echo " ⮞ Configuring sparse checkout (headless)"
        echo "/*" > "$sparse_file"
        for path in "${HEADLESS_EXCLUDES[@]}"; do
            echo "!/$path" >> "$sparse_file"
        done
    elif [ "$ALL" = true ] || [ ! -f "$sparse_file" ]; then
        echo " ⮞ Configuring sparse checkout (all files)"
        echo "/*" > "$sparse_file"
    else
        print_dim " ✓ Sparse checkout already configured"
    fi
}

init_repo() {
    print_bold "Setting up repo in $DOTFILES_DIR"

    # delete previous repo if it exists
    if [ -d "$DOTFILES_DIR" ]; then
        rm -rf "$DOTFILES_DIR"
    fi

    clone_repo
    setup_sparse_checkout
}

print_checkout_changes() {
    local changed_files="$1"
    local message="$2"
    local color="$3"
    local reset_color="\e[0m"

    if [ -n "$changed_files" ]; then
        echo -e "$message"
        echo "$changed_files" | while read -r line; do
            [ -n "$line" ] || continue
            code="${line:0:2}"
            path="${line:2}"
            printf " ${color}%s${reset_color}%s\n" "$code" "$path"
        done
    else
        print_dim " ✓ No file conflicts found"
    fi
}

checkout_files() {
    print_bold "Checking out files to $HOME"

    # internal backup directory
    local BACKUP_DIR="$DOTFILES_DIR/.bootstrap-backup"

    # list of changed files
    local changed_files=""
    # iterate through all file paths tracked in HEAD
    while IFS= read -r file; do
        local full_path="$HOME/$file"

        # skip if not a regular file
        if [ ! -f "$full_path" ]; then
            continue
        fi

        # skip if file is an image (by extension)
        case "${file##*.}" in
            png|jpg|jpeg|gif|bmp|svg|ico|tiff|webp) continue ;;
        esac

        # check if local file differs with HEAD version
        if ! diff -q "$full_path" <(dotfiles show HEAD:"$file") > /dev/null 2>&1; then
            changed_files+=$'M '"$file"$'\n'

            # preserve local file if not forcing overwrite
            if [ "$FORCE" = false ]; then
                local backup_path="$BACKUP_DIR/$file"
                mkdir -p "$(dirname "$backup_path")"
                cp "$full_path" "$backup_path"
            fi
        fi
    done < <(dotfiles ls-tree -r --name-only HEAD)

    # print changed files
    if [ "$FORCE" = true ]; then
        print_checkout_changes "$changed_files" "Files overwritten due to --force during clone:" "\e[31m"
    else
        print_checkout_changes "$changed_files" "Files preserved during clone (overwrite with --force):" "\e[33m"
    fi

    # checkout (will overwrite local files)
    dotfiles checkout --quiet 2> /dev/null

    # restore files if not forcing overwrite
    if [ "$FORCE" = false ] && [ -d "$BACKUP_DIR" ]; then
        find "$BACKUP_DIR" -type f | while IFS= read -r backup_file; do
            rel_path="${backup_file#$BACKUP_DIR/}"
            dest_path="$HOME/$rel_path"
            mkdir -p "$(dirname "$dest_path")"
            cp "$backup_file" "$dest_path"
        done
        # delete backup directory
        rm -rf "$BACKUP_DIR"
    fi
}

main() {
    parse_args "$@"

    init_repo
    echo

    checkout_files
    echo

    print_bold "Bootstrap complete"
    dotfiles status | grep "sparse checkout" | sed 's/^You are in a sparse checkout with /Sparse checkout: /; s/\.$//'
}

main "$@"
