#!/usr/bin/env bash

set -euo pipefail

REPO_URL="git@github.com:tk755/dotfiles.git"
DOTFILES_DIR="$HOME/.dotfiles"

# paths to exclude in headless install
HEADLESS_EXCLUDES=(
    ".config/i3"
    ".fonts"
    ".icons"
    ".themes"
    ".Xresources"
)

# default flags
HEADLESS=false
ALL=false
FORCE=false

print_help() {
    cat <<EOF
Usage: bootstrap [OPTIONS]

Options:
    --all           Include all dotfiles (default on first install)
    --headless      Exclude GUI-related dotfiles (for servers or WSL)
    --force         Force overwrite local files (destructive)
    --help          Show this help message

Exclude patterns (--headless):
    ${HEADLESS_EXCLUDES[*]}

Description:
    Installs dotfiles using a bare git repository at:
        $DOTFILES_DIR

    If the repository does not exist, it will be cloned from:
        $REPO_URL

    Uses sparse checkout to include only a subset of files:
      - Use --headless to exclude GUI-related files.
      - Use --all to include everything.
      - If neither is specified, the previous sparse config is reused.
        If none exists, defaults to --all.
      - These options are mutually exclusive.

    File conflict behavior:
      - Conflicting files are skipped by default, with a warning.
      - Use --force to overwrite them (this is locally destructive).
EOF
}

parse_args() {
    for arg in "$@"; do
        case "$arg" in
            --all)      ALL=true                    ;;
            --headless) HEADLESS=true               ;;
            --force)    FORCE=true                  ;;
            --help)     print_help && exit 0        ;;
            *) echo "Invalid arg: $arg" && exit 1   ;;
        esac
    done

    if [ $ALL = true ] && [ $HEADLESS = true ]; then
        echo "Error: --headless and --all are mutually exclusive." >&2
        exit 1
    fi
}

print_bold() {
    printf "\e[1m%s\e[0m\n" "$1"
}

print_dim() {
    printf "\e[2m%s\e[0m\n" "$1"
}

# dotfiles git wrapper function
dotfiles() {
    git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

init_repo() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        # clone bare repo
        echo " ⮞ Cloning repo from $REPO_URL"
        git clone --bare "$REPO_URL" "$DOTFILES_DIR" &> /dev/null

        # manually configure tracking
        dotfiles config branch.main.remote origin
        dotfiles config branch.main.merge refs/heads/main

        # disable untracked files in status
        dotfiles config --local status.showUntrackedFiles no

        # enable + setup sparse checkout
        dotfiles config core.sparseCheckout true
    else
        print_dim " ✓ Bare repo already exists"
    fi
}

setup_sparse_checkout() {
    # create sparse checkout file if it doesn't exist
    local sparse_file="$DOTFILES_DIR/info/sparse-checkout"
    mkdir -p "$(dirname "$sparse_file")"

    # update sparse checkout file 
    if [ "$HEADLESS" = true ]; then
        echo " ⮞ Configuring sparse checkout (headless)"
        echo "/*" > "$sparse_file"
        for path in "${HEADLESS_EXCLUDES[@]}"; do
            echo "!/$path" >> "$sparse_file"
        done
    elif [ "$ALL" = true ] || [ ! -f "$sparse_file" ]; then
        echo " ⮞ Configuring sparse checkout (all files)"
        echo "/*" > "$sparse_file"
    else
        print_dim " ✓ Sparse checkout already configured"
    fi
}

setup_repo() {
    print_bold "Setting up repo in $DOTFILES_DIR"
    init_repo
    setup_sparse_checkout
}

print_checkout_changes() {
    local message="$1"
    local color="$2"
    local reset_color="\e[0m"

    local changed_files=$(dotfiles status --porcelain | grep -E '^[ MDAU?!]{2} ' || true)
    if [ -n "$changed_files" ]; then
        echo -e "$message"
        echo "$changed_files" | while read -r line; do
            code="${line:0:2}"
            path="${line:2}"
            printf " ${color}%s${reset_color}%s\n" "$code" "$path"
        done
    else
        print_dim " ✓ No file conflicts found"
    fi
}

checkout_files() {
    print_bold "Checking out files to $HOME"
    if [ "$FORCE" = true ]; then
        print_checkout_changes "Files overwritten due to --force:" "\e[31m"
        dotfiles checkout --force --quiet 2> /dev/null
    else
        dotfiles checkout --quiet 2> /dev/null
        print_checkout_changes "Files skipped due to local changes (overwrite with --force):" "\e[33m"
    fi
}

main() {
    parse_args "$@"

    setup_repo
    echo

    checkout_files
    echo

    print_bold "Bootstrap complete"
    dotfiles status | grep "sparse checkout" | sed 's/^You are in a sparse checkout with /Sparse checkout: /; s/\.$//'
}

main "$@"
