#!/usr/bin/env bash
# bootstrap - dotfiles installer using a bare git repo
# For usage instructions, run `bootstrap --help`

set -euo pipefail

REPO_URL="git@github.com:tk755/dotfiles.git"
DOTFILES_DIR="$HOME/.dotfiles"

# paths to exclude in headless install
HEADLESS_EXCLUDES=(
    ".config/i3"
    ".fonts"
    ".icons"
    ".themes"
    ".Xresources"
)

# default flags
HEADLESS=false
FORCE=false

print_help() {
    cat <<EOF
Usage: bootstrap [OPTIONS]

Options:
    --headless     Exclude GUI-related dotfiles
    --force        Overwrite conflicting files (locally destructive)
    --help         Show this help message
EOF
}

parse_args() {
    for arg in "$@"; do
        case "$arg" in
            --headless) HEADLESS=true                   ;;
            --force)    FORCE=true                      ;;
            --help)     print_help && exit 0            ;;
            *) echo "Invalid option: $arg" && exit 1    ;;
        esac
    done
}

print_bold() {
    printf "\e[1m%s\e[0m\n" "$1"
}

print_dim() {
    printf "\e[2m%s\e[0m\n" "$1"
}

# dotfiles git wrapper function
dotfiles() {
    git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

clone_repo() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        print_bold "Cloning bare repo $REPO_URL to $DOTFILES_DIR"
        git clone --bare "$REPO_URL" "$DOTFILES_DIR"
    else
        print_dim "Using existing bare repo at $DOTFILES_DIR"
    fi
}

configure_repo() {
    dotfiles config --local status.showUntrackedFiles no
    dotfiles config core.sparseCheckout true

    # only set upstream if it's not already set
    if ! dotfiles rev-parse --abbrev-ref --symbolic-full-name @{u} &> /dev/null; then
        dotfiles branch --set-upstream-to=origin/main main &> /dev/null || true
    fi
}

setup_sparse_checkout() {
    echo
    local sparse_file="$DOTFILES_DIR/info/sparse-checkout"
    mkdir -p "$(dirname "$sparse_file")"

    if [ "$HEADLESS" = true ]; then
        print_bold "Configuring sparse checkout (headless)"
        echo "/*" > "$sparse_file"
        for path in "${HEADLESS_EXCLUDES[@]}"; do
            echo "!/$path" >> "$sparse_file"
        done
    elif [ ! -f "$sparse_file" ]; then
        print_bold "Configuring sparse checkout (all files)"
        echo "/*" > "$sparse_file"
    else
        print_dim "Using existing sparse checkout config"
    fi
}

print_checkout_changes() {
    local message="$1"
    local color="$2"
    local reset_color="\e[0m"

    local changed_files=$(dotfiles status --porcelain | grep -E '^[ MDAU?!]{2} ' || true)
    if [ -n "$changed_files" ]; then
        echo -e "$message"
        echo "$changed_files" | while read -r line; do
            code="${line:0:2}"
            path="${line:2}"
            printf "  ${color}%s${reset_color} %s\n" "$code" "$path"
        done
    else
        print_dim "No file conflicts found"
    fi
}

checkout_files() {
    echo
    print_bold "Checking out files to $HOME"
    if [ "$FORCE" = true ]; then
        print_checkout_changes "Files overwritten due to --force:" "\e[31m"
        dotfiles checkout --force --quiet
    else
        dotfiles checkout --quiet
        print_checkout_changes "Files skipped due to local changes (overwrite with --force):" "\e[33m"
    fi
}

print_final_status() {
    echo
    print_bold "Installation complete"
    dotfiles status | grep "sparse checkout" | sed 's/^You are in a sparse checkout with /Sparse checkout: /; s/\.$//'
}

init_repo() {
    clone_repo
    configure_repo
    setup_sparse_checkout
    checkout_files
}

parse_args "$@"
# print_bold "Running bootstrap"
init_repo
print_final_status