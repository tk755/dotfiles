#!/usr/bin/env bash

set -euo pipefail

REPO_URL_HTTPS="https://github.com/tk755/dotfiles.git"
DOTFILES_DIR="$HOME/.dotfiles"

# paths to exclude in headless install
HEADLESS_EXCLUDES=(
    ".config/i3"
    ".fonts"
    ".icons"
    ".themes"
    ".Xresources"
)

# default flags
HEADLESS=false
ALL=false
FORCE=false
CLONED=false

print_help() {
    cat <<EOF
Usage: bootstrap [OPTIONS]

Options:
    --all           Include all dotfiles (default on first install)
    --headless      Exclude GUI-related dotfiles (for servers or WSL)
    --force         Force overwrite local files (destructive)
    --help          Show this help message

Exclude patterns (--headless):
    ${HEADLESS_EXCLUDES[*]}

Description:
    Installs dotfiles using a bare git repository at:
        $DOTFILES_DIR

    If the repository does not exist, it will be cloned from:
        $REPO_URL_SSH

    Uses sparse checkout to include only a subset of files:
      - Use --headless to exclude GUI-related files.
      - Use --all to include everything.
      - If neither is specified, the previous sparse config is reused.
        If none exists, defaults to --all.
      - These options are mutually exclusive.

    File conflict behavior:
      - On a new clone, conflicting non-image files are preserved and restored.
        Use --force to overwrite them without preserving (destructive).
      - On subsequent runs, conflicting files are skipped by default.
        Use --force to overwrite them (destructive).
EOF
}

parse_args() {
    for arg in "$@"; do
        case "$arg" in
            --all)      ALL=true                    ;;
            --headless) HEADLESS=true               ;;
            --force)    FORCE=true                  ;;
            --help)     print_help && exit 0        ;;
            *) echo "Invalid arg: $arg" && exit 1   ;;
        esac
    done

    if [ $ALL = true ] && [ $HEADLESS = true ]; then
        echo "Error: --headless and --all are mutually exclusive." >&2
        exit 1
    fi
}

print_bold() {
    printf "\e[1m%s\e[0m\n" "$1"
}

print_dim() {
    printf "\e[2m%s\e[0m\n" "$1"
}

# dotfiles git wrapper function
dotfiles() {
    git --git-dir="$DOTFILES_DIR" --work-tree="$HOME" "$@"
}

clone_repo() {
    # clone via HTTPS to avoid SSH setup issues
    echo " ⮞ Cloning repo from $REPO_URL_HTTPS"
    git clone --bare "$REPO_URL_HTTPS" "$DOTFILES_DIR" &> /dev/null
    CLONED=true

    # switch to SSH for future pushes
    REPO_URL_SSH="git@github.com:${REPO_URL_HTTPS#https://github.com/}"
    git --git-dir="$DOTFILES_DIR" remote set-url origin "$REPO_URL_SSH"

    # manually configure tracking
    dotfiles config branch.main.remote origin
    dotfiles config branch.main.merge refs/heads/main

    # disable untracked files in status
    dotfiles config --local status.showUntrackedFiles no

    # enable
    dotfiles config core.sparseCheckout true
    CLONED=true
}

init_repo() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        clone_repo
    else
        print_dim " ✓ Bare repo already exists"
    fi
}

setup_sparse_checkout() {
    # create sparse checkout file if it doesn't exist
    local sparse_file="$DOTFILES_DIR/info/sparse-checkout"
    mkdir -p "$(dirname "$sparse_file")"

    # update sparse checkout file 
    if [ "$HEADLESS" = true ]; then
        echo " ⮞ Configuring sparse checkout (headless)"
        echo "/*" > "$sparse_file"
        for path in "${HEADLESS_EXCLUDES[@]}"; do
            echo "!/$path" >> "$sparse_file"
        done
    elif [ "$ALL" = true ] || [ ! -f "$sparse_file" ]; then
        echo " ⮞ Configuring sparse checkout (all files)"
        echo "/*" > "$sparse_file"
    else
        print_dim " ✓ Sparse checkout already configured"
    fi
}

setup_repo() {
    print_bold "Setting up repo in $DOTFILES_DIR"
    init_repo
    setup_sparse_checkout
}

is_image_file() {
    case "${1##*.}" in
        png|jpg|jpeg|gif|bmp|svg|ico|tiff|webp) return 0 ;;
        *) return 1 ;;
    esac
}

print_checkout_changes() {
    local changed_files="$1"
    local message="$2"
    local color="$3"
    local reset_color="\e[0m"

    if [ -n "$changed_files" ]; then
        echo -e "$message"
        echo "$changed_files" | while read -r line; do
            [ -n "$line" ] || continue
            code="${line:0:2}"
            path="${line:2}"
            printf " ${color}%s${reset_color}%s\n" "$code" "$path"
        done
    else
        print_dim " ✓ No file conflicts found"
    fi
}

checkout_files() {
    print_bold "Checking out files to $HOME"

    if [ "$CLONED" = true ]; then
        # internal backup directory
        local BACKUP_DIR="$DOTFILES_DIR/.bootstrap-backup"

        # iterate through all file paths tracked in HEAD
        local changed_files=""
        while IFS= read -r file; do
            local full_path="$HOME/$file"

            # skip if not a regular file or is an image
            if [ ! -f "$full_path" ] || is_image_file "$file"; then
                continue
            fi

            # compare local file with HEAD version
            if ! diff -q "$full_path" <(dotfiles show HEAD:"$file") > /dev/null 2>&1; then
                changed_files+=$'M '"$file"$'\n'

                # preserve local file
                if [ "$FORCE" = false ]; then
                    local backup_path="$BACKUP_DIR/$file"
                    mkdir -p "$(dirname "$backup_path")"
                    cp "$full_path" "$backup_path"
                fi
            fi
        done < <(dotfiles ls-tree -r --name-only HEAD)

        if [ "$FORCE" = true ]; then
            print_checkout_changes "$changed_files" "Files overwritten due to --force during clone:" "\e[31m"
        else
            print_checkout_changes "$changed_files" "Files preserved during clone (overwrite with --force):" "\e[33m"
        fi

        # checkout (will overwrite local files)
        dotfiles checkout --quiet 2> /dev/null

        # restore files
        if [ "$FORCE" = false ] && [ -d "$BACKUP_DIR" ]; then
            find "$BACKUP_DIR" -type f | while IFS= read -r backup_file; do
                rel_path="${backup_file#$BACKUP_DIR/}"
                dest_path="$HOME/$rel_path"
                mkdir -p "$(dirname "$dest_path")"
                cp "$backup_file" "$dest_path"
            done
            rm -rf "$BACKUP_DIR"
        fi

    elif [ "$FORCE" = true ]; then
        changed_files=$(dotfiles status --porcelain | grep -E '^[ MDAU?!]{2} ' || true)
        print_checkout_changes "$changed_files" "Files overwritten due to --force:" "\e[31m"
        dotfiles checkout --force --quiet 2> /dev/null

    else
        dotfiles checkout --quiet 2> /dev/null
        changed_files=$(dotfiles status --porcelain | grep -E '^[ MDAU?!]{2} ' || true)
        print_checkout_changes "$changed_files" "Files skipped due to local changes (overwrite with --force):" "\e[33m"
    fi
}

main() {
    parse_args "$@"

    setup_repo
    echo

    checkout_files
    echo

    print_bold "Bootstrap complete"
    dotfiles status | grep "sparse checkout" | sed 's/^You are in a sparse checkout with /Sparse checkout: /; s/\.$//'
}

main "$@"
